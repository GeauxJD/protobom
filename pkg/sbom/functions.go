package sbom

import (
	"fmt"
	"regexp"
	"strings"
	"unicode/utf8"

	"github.com/CycloneDX/cyclonedx-go"
	cdx "github.com/CycloneDX/cyclonedx-go"
	"github.com/google/uuid"
)

// NodeIdentifierPrefix known protobom prefix
const NodeIdentifierPrefix = "protobom"

var (
	// invalidIDCharsRe represents the regex for allowed characters in the prefix.
	// Invalid characters are replaced with unicode numbers to avoid collisions.
	invalidIDCharsRe = regexp.MustCompile(`[^a-zA-Z0-9-.]+`)
	// protobomPrefixes is a map of known protobom autogenerated prefixes.
	protobomPrefixes = map[string]string{"auto": "auto", "node": "node"}
)

// NewNodeIdentifier generates an identifier string compatible with CycloneDX and SPDX for use in a node.
//
// If no prefixes are provided, the identifier will be created using a new UUID and prefixed with "protobom-xx-yy--".
// The prefix allows serializers to interpret characteristics, such as "auto," indicating it was autogenerated by protobom.
//
// If prefixes are provided, they are used to build the identifier. Invalid characters are removed, and known separators
// are replaced with dashes. If no valid prefixes are found, a UUID will be used by default.
func NewNodeIdentifier(prefixes ...string) string {
	validPrefixes := []string{}
	knownPrefixes := []string{NodeIdentifierPrefix}
	for _, s := range prefixes {
		if _, ok := protobomPrefixes[s]; ok && len(validPrefixes) == 0 {
			knownPrefixes = append(knownPrefixes, s)
			continue
		}
		// Replace known separators to dashes to keep readability
		for _, r := range []string{"/", ":", " "} {
			s = strings.ReplaceAll(s, r, "-")
		}
		// Replace invalid chars with unicode numbers to avoid collisions
		s = invalidIDCharsRe.ReplaceAllStringFunc(s, func(s string) (r string) {
			for i := 0; i < len(s); i++ {
				uc, _ := utf8.DecodeRuneInString(string(s[i]))
				r = fmt.Sprintf("%sC%d", r, uc)
			}
			return r
		})
		if s != "" {
			validPrefixes = append(validPrefixes, s)
		}
	}

	// If we did not get any seeds, use an UUID
	if len(validPrefixes) == 0 {
		validPrefixes = append(validPrefixes, uuid.New().String())
	}

	validPrefixes[0] = "-" + validPrefixes[0]

	return strings.Join(append(knownPrefixes, validPrefixes...), "-")
}

// EdgeTypeFromSPDX converts an SPDX2 edge type string to its corresponding edge type.
func EdgeTypeFromSPDX(spdxName string) Edge_Type {
	switch spdxName {
	case "AMENDS":
		return Edge_AMENDS
	case "ANCESTOR_OF":
		return Edge_ANCESTOR
	case "BUILD_DEPENDENCY_OF":
		return Edge_BUILD_DEPENDENCY
	case "BUILD_TOOL_OF":
		return Edge_BUILD_TOOL
	case "CONTAINS":
		return Edge_CONTAINS
	case "COPY_OF":
		return Edge_COPY
	case "DATA_FILE_OF":
		return Edge_DATA_FILE
	case "DEPENDENCY_MANIFEST_OF":
		return Edge_DEPENDENCY_MANIFEST
	case "DEPENDS_ON":
		return Edge_DEPENDS_ON
	case "DESCENDANT_OF":
		return Edge_DESCENDANT
	case "DESCRIBES":
		return Edge_DESCRIBES
	case "DEV_DEPENDENCY_OF":
		return Edge_DEV_DEPENDENCY
	case "DEV_TOOL_OF":
		return Edge_DEV_TOOL
	case "DISTRIBUTION_ARTIFACT":
		return Edge_DISTRIBUTION_ARTIFACT
	case "DOCUMENTATION_OF":
		return Edge_DOCUMENTATION
	case "DYNAMIC_LINK":
		return Edge_DYNAMIC_LINK
	case "EXAMPLE_OF":
		return Edge_EXAMPLE
	case "EXPANDED_FROM_ARCHIVE":
		return Edge_EXPANDED_FROM_ARCHIVE
	case "FILE_ADDED":
		return Edge_FILE_ADDED
	case "FILE_DELETED":
		return Edge_FILE_DELETED
	case "FILE_MODIFIED":
		return Edge_FILE_MODIFIED
	case "GENERATES":
		return Edge_GENERATES
	case "METAFILE_OF":
		return Edge_METAFILE
	case "OPTIONAL_COMPONENT_OF":
		return Edge_OPTIONAL_COMPONENT
	case "OPTIONAL_DEPENDENCY_OF":
		return Edge_OPTIONAL_DEPENDENCY
	case "OTHER":
		return Edge_OTHER
	case "PACKAGE_OF":
		return Edge_PACKAGES
	case "PATCH_FOR":
		return Edge_PATCH
	case "HAS_PREREQUISITE":
		return Edge_PREREQUISITE
	case "PROVIDED_DEPENDENCY_OF":
		return Edge_PROVIDED_DEPENDENCY
	case "REQUIREMENT_DESCRIPTION_FOR":
		return Edge_REQUIREMENT_FOR
	case "RUNTIME_DEPENDENCY_OF":
		return Edge_RUNTIME_DEPENDENCY
	case "SPECIFICATION_FOR":
		return Edge_SPECIFICATION_FOR
	case "STATIC_LINK":
		return Edge_STATIC_LINK
	case "TEST_OF":
		return Edge_TEST
	case "TEST_CASE_OF":
		return Edge_TEST_CASE
	case "TEST_DEPENDENCY_OF":
		return Edge_TEST_DEPENDENCY
	case "TEST_TOOL_OF":
		return Edge_TEST_TOOL
	case "VARIANT_OF":
		return Edge_VARIANT
	default:
		return Edge_UNKNOWN
	}
}

// HashAlgorithmFromCDX converts a CycloneDX hash algorithm to its corresponding Hash Algorithm.
func HashAlgorithmFromCDX(cdxAlgorithm cyclonedx.HashAlgorithm) HashAlgorithm {
	switch cdxAlgorithm {
	case cdx.HashAlgoMD5:
		return HashAlgorithm_MD5
	case cdx.HashAlgoSHA1:
		return HashAlgorithm_SHA1
	case cdx.HashAlgoSHA256:
		return HashAlgorithm_SHA256
	case cdx.HashAlgoSHA384:
		return HashAlgorithm_SHA384
	case cdx.HashAlgoSHA512:
		return HashAlgorithm_SHA512
	case cdx.HashAlgoSHA3_256:
		return HashAlgorithm_SHA3_256
	case cdx.HashAlgoSHA3_384:
		return HashAlgorithm_SHA3_384
	case cdx.HashAlgoSHA3_512:
		return HashAlgorithm_SHA3_512
	case cdx.HashAlgoBlake2b_256:
		return HashAlgorithm_BLAKE2B_256
	case cdx.HashAlgoBlake2b_384:
		return HashAlgorithm_BLAKE2B_384
	case cdx.HashAlgoBlake2b_512:
		return HashAlgorithm_BLAKE2B_512
	case cdx.HashAlgoBlake3:
		return HashAlgorithm_BLAKE3
	default:
		return HashAlgorithm_UNKNOWN
	}
}
